<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bang Tidy Clothing Customisation App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root { --bd:#ddd; --muted:#666; --bg:#fafafa; --fg:#111; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; color: var(--fg); }
    h1 { margin: 0 0 12px; }
    .card { margin-top: 1rem; padding: 12px; border: 1px solid var(--bd); border-radius: 12px; background: #fff; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    button { padding: 9px 14px; border: 1px solid var(--bd); background: #fff; border-radius: 8px; cursor: pointer; }
    input[type="text"], input[type="url"], input[type="file"] { padding: 9px 10px; border: 1px solid var(--bd); border-radius: 8px; min-width: 220px; }
    label { display:block; font-weight: 600; margin-top: 10px; }
    small { color: var(--muted); }
    ul { padding-left: 18px; margin: 6px 0 0; }
    #templates-status { margin-top:6px; color: var(--muted); }
    .hidden { display: none !important; }
    .error { color: #b00020; }
    .success { color: #0f7b0f; }
  </style>
</head>
<body>
  <h1>Customisation App</h1>

  <!-- Templates list -->
  <div id="templates" class="card">
    <strong>Templates</strong>
    <div id="templates-status">Loading…</div>
    <ul id="templates-list"></ul>
  </div>

  <!-- Simulator -->
  <div class="card" id="simPanel">
    <strong>Simulate Jotform</strong>
    <div class="row" style="margin-top:8px;">
      <input id="simTpl" placeholder="template_id (e.g. CO-CARD-PHOTO-12)" />
      <input id="simName" placeholder="name" />
      <input id="simOrder" placeholder="orderId" />
      <input id="simPhoto" placeholder="photo URL (optional)" />
      <button id="simBtn">Start</button>
    </div>
    <div style="margin-top:8px; color: var(--muted); font-size: 12px;">
      Tip: click a template in the list to auto-fill its ID, then click Start.
    </div>
  </div>

  <!-- Customiser (fallback when no TYPE page exists) -->
  <div id="customiser" class="card hidden">
    <div id="c-head"><strong id="c-title"></strong></div>
    <form id="c-form" style="margin-top:8px;"></form>

    <div id="c-preview" style="margin-top:10px;">
      <div style="margin-bottom:6px;"><strong>Preview</strong></div>
      <div id="svgMount" style="border:1px solid #ddd; border-radius:8px; overflow:hidden;"></div>
    </div>

    <div id="c-errors" class="error" style="margin-top:8px;"></div>
    <div class="row" style="margin-top:10px;">
      <button id="c-submit" type="button">Continue</button>
      <button id="c-cancel" type="button">Cancel</button>
    </div>
    <div id="c-done" class="success" style="margin-top:10px;"></div>
  </div>

  <script>
  // ---- Params reader (query OR hash) ----
  function getParams() {
    const qs = new URLSearchParams(location.search);
    if (qs.toString()) return qs;
    const h = (location.hash || "").replace(/^#/, "");
    return new URLSearchParams(h);
  }
  function qp(k){ return getParams().get(k) || ""; }

  // ---- API loader ----
  async function loadTemplates() {
    const PROXY_URL = "https://customisationapp-new.vercel.app/api/templates?slug=1&type=kebab";
    const res = await fetch(PROXY_URL, { credentials: "omit", cache: "no-store" });
    if (!res.ok) { console.error("Template fetch failed", res.status); return []; }
    const data = await res.json();
    return (Array.isArray(data.records) ? data.records : [])
      .map(normalizeRecord)
      .filter(r => r.template_id); // drop blanks
  }

  // ---- Safe URL ----
    // ---- Local image preview state ----
const localImages = new Map(); // key -> { objectUrl }
function clearLocalImages(){
  for (const v of localImages.values()) { try { URL.revokeObjectURL(v.objectUrl); } catch{} }
  localImages.clear();
}

// Build the current inputs map, preferring local object URLs for image fields
function currentInputsForPreview(template){
  const out = { template_id: template?.template_id || '' };
  const visible = getVisibleFields(template);
  visible.forEach(f => {
    if (f.type === 'text') {
      out[f.key] = (document.getElementById(`f_${f.key}`)?.value || '').trim();
    } else if (f.type === 'image') {
      const local = localImages.get(f.key);
      if (local?.objectUrl) {
        out[f.key] = local.objectUrl;
      } else {
        out[f.key] = (document.getElementById(`f_${f.key}_url`)?.value || '').trim();
      }
    }
  });
  return out;
}

  function safeUrl(u){ try { const url = new URL(u); return url.href; } catch { return ""; } }

  // ---- Normalisers ----
  function clean(s){ return String(s||'').replace(/\s+/g,' ').trim(); }
  function toSlug(s){ return clean(s).toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,''); }
  function parseTemplateId(input){
    // grab first id-like token (letters/numbers/_/-), ignore long pasted lines
    const s = String(input||'').trim();
    const m = s.match(/[A-Za-z0-9_]+(?:-[A-Za-z0-9_]+)*/);
    return m ? m[0] : clean(s);
  }
  function normalizeRecord(t){
    const id   = clean(t.template_id);
    const name = clean(t.name);
    const TYPE = clean(t.TYPE || t.type || '');
    const typeKebab = t.type ? clean(t.type) : toSlug(TYPE);
    let base = t.base_image;
    if (Array.isArray(base) && base[0]?.url) base = base[0].url; // Airtable attachment -> URL
    return { ...t, template_id:id, name, TYPE, type:typeKebab, base_image: base || null };
  }

  // ---- Render list ----
  async function renderList() {
    const listEl = document.getElementById("templates-list");
    const statusEl = document.getElementById("templates-status");
    const records = await loadTemplates();

    if (!records.length) { statusEl.textContent = "No templates found"; return records; }
    statusEl.remove();

    const frag = document.createDocumentFragment();
    records.forEach(t => {
      const li = document.createElement("li");
      const typeLabel = (t.type || toSlug(t.TYPE || '')).replace(/-/g,' ');
      const typeTitle = typeLabel ? typeLabel.replace(/\b\w/g, c => c.toUpperCase()) : "";
      li.textContent = `${t.template_id} — ${t.name ?? ""}${typeTitle ? " — TYPE: " + typeTitle : ""}`;
      frag.appendChild(li);
    });
    listEl.appendChild(frag);
    return records;
  }

  // ---- Field filtering using table-level flags ----
  function getVisibleFields(template) {
    const layoutKeys = new Set((template.layout?.elements || []).map(e => e.key).filter(Boolean));
    const wantsPhoto = template.requires_photo !== false;
    const wantsText  = template.requires_text  !== false;

    let fields = Array.isArray(template.fields) ? template.fields : [];
    if (layoutKeys.size) fields = fields.filter(f => layoutKeys.has(f.key));

    fields = fields.filter(f => {
      if (f.type === 'image' && !wantsPhoto) return false;
      if (f.type === 'text'  && !wantsText)  return false;
      return true;
    });

    fields = fields.filter(f => f.hidden !== true && f.editable !== false);
    return fields;
  }

  // ---- Determine effective 'required' based on optional flags ----
  function isFieldRequired(template, field) {
    const optAll   = !!template.optional;
    const optPhoto = !!template.optional_photo;
    const optText  = !!template.optional_text;
    if (optAll) return false;
    if (field.type === 'image' && optPhoto) return false;
    if (field.type === 'text'  && optText)  return false;
    return !!field.required;
  }

  // ---- Generic builder ----
  function buildForm(template, prefill) {
    const form = document.getElementById('c-form');
    form.innerHTML = "";

    const fields = getVisibleFields(template);

    fields.forEach(field => {
      const wrap = document.createElement('div');
      const required = isFieldRequired(template, field);

      if (field.type === 'text') {
        const id = `f_${field.key}`;
        wrap.innerHTML = `
          <label for="${id}">${field.label || field.key}</label>
          <input id="${id}" name="${field.key}" type="text"
                 ${field.maxLength ? `maxlength="${field.maxLength}"`:''}
                 ${required ? 'required' : ''}
                 value="${(prefill?.[field.key]||'').replace(/"/g,'&quot;')}">
          ${field.maxLength ? `<small>Max ${field.maxLength} characters</small>` : ''}
          ${required ? `<small>(required)</small>` : `<small>(optional)</small>`}
        `;
      } else if (field.type === 'image') {
        const id = `f_${field.key}`;
        wrap.innerHTML = `
          <label>${field.label || field.key}</label>
          <input id="${id}_url" type="url" placeholder="Paste image URL" value="${prefill?.[field.key]||''}" ${required ? 'required' : ''}>
          <input id="${id}_file" type="file"
                 accept="${(field.constraints?.formats||['jpg','jpeg','png']).map(x=>'.'+x).join(',')}">
          ${required ? `<small>(required)</small>` : `<small>(optional)</small>`}
        `;
      } else {
        wrap.innerHTML = `<label>${field.label || field.key} (unsupported)</label>`;
      }
      form.appendChild(wrap);
    });
  }

  // ---- Collect form ----
  async function collectForm(template) {
    const out = {};
    const errs = [];
    const fields = getVisibleFields(template);

    for (const field of fields) {
      const required = isFieldRequired(template, field);

      if (field.type === 'text') {
        const el = document.getElementById(`f_${field.key}`);
        const val = (el?.value || "").trim();
        if (required && !val) errs.push(`${field.label||field.key} is required`);
        out[field.key] = val;
      }
      if (field.type === 'image') {
        const urlEl = document.getElementById(`f_${field.key}_url`);
        const fileEl = document.getElementById(`f_${field.key}_file`);
        let val = (urlEl?.value || "").trim();
        if (!val && fileEl?.files?.[0]) val = fileEl.files[0].name; // placeholder until upload
        if (required && !val) errs.push(`${field.label||field.key} is required`);
        out[field.key] = val;
      }
    }
    return { out, errs };
  }

  // ---- Map form inputs to layout keys (handles key mismatches) ----
  function normalizeInputsForLayout(layout, inputs, fields){
    const out = { ...inputs };
    const textKeys  = (fields || []).filter(f => f.type === 'text').map(f => f.key);
    const imageKeys = (fields || []).filter(f => f.type === 'image').map(f => f.key);
    (layout?.elements || []).forEach(el => {
      if (el.type === 'text' && !out[el.key]) {
        if (textKeys.length === 1) out[el.key] = inputs[textKeys[0]] || '';
      }
      if (el.type === 'image' && !out[el.key]) {
        if (imageKeys.length === 1) out[el.key] = inputs[imageKeys[0]] || '';
      }
    });
    return out;
  }

  // ---- SVG composer (with base image + text fill support) ----
  function computeImageFit(imgW, imgH, boxW, boxH, mode='cover'){
    const rImg = imgW / imgH, rBox = boxW / boxH;
    let w,h; if (mode==='cover'){ if (rImg>rBox){ h=boxH; w=h*rImg; } else { w=boxW; h=w/rImg; } }
    else { if (rImg>rBox){ w=boxW; h=w/rImg; } else { h=boxH; w=h*rImg; } }
    return { x:(boxW-w)/2, y:(boxH-h)/2, w, h };
  }

  async function composeSVG(layout, inputs, baseUrl){
    if (!layout) return '';
    const [cw, ch] = layout.canvasMM || [100,100];
    const vbW = cw, vbH = ch;

    const imgInfo = {};
    async function imgSize(url){
      if (!url) return null;
      if (imgInfo[url]) return imgInfo[url];
      const img = new Image(); img.crossOrigin='anonymous';
      const p = new Promise(r=>{ img.onload=()=>r({w:img.naturalWidth,h:img.naturalHeight}); img.onerror=()=>r(null); });
      img.src = url; const s = await p; imgInfo[url]=s; return s;
    }

    const parts = [
      `<svg xmlns="http://www.w3.org/2000/svg" width="${cw}mm" height="${ch}mm" viewBox="0 0 ${vbW} ${vbH}">`,
      `<rect x="0" y="0" width="${vbW}" height="${vbH}" fill="white"/>`
    ];

    // base image
    if (baseUrl) {
      const s = await imgSize(baseUrl);
      if (s) {
        const fit = computeImageFit(s.w, s.h, vbW, vbH, 'contain');
        parts.push(`<image href="${baseUrl.replace(/"/g,'&quot;')}" x="${fit.x}" y="${fit.y}" width="${fit.w}" height="${fit.h}" preserveAspectRatio="none"/>`);
      } else {
        parts.push(`<image href="${baseUrl.replace(/"/g,'&quot;')}" x="0" y="0" width="${vbW}" height="${vbH}" preserveAspectRatio="none"/>`);
      }
    }

    // elements
    for (const el of (layout.elements||[])){
      if (el.type==='image'){
        const url = inputs[el.key]; if (!url) continue;
        const box = {x:el.x||0,y:el.y||0,w:el.w||vbW,h:el.h||vbH};
        const s = await imgSize(url);
        if (s){ const fit = computeImageFit(s.w,s.h,box.w,box.h,el.fit||'cover');
          parts.push(`<image href="${url.replace(/"/g,'&quot;')}" x="${box.x+fit.x}" y="${box.y+fit.y}" width="${fit.w}" height="${fit.h}" preserveAspectRatio="none"/>`);
        } else {
          parts.push(`<image href="${url.replace(/"/g,'&quot;')}" x="${box.x}" y="${box.y}" width="${box.w}" height="${box.h}" preserveAspectRatio="none"/>`);
        }
      }
      if (el.type==='text'){
        const val = (inputs[el.key]||'')+''; if (!val) continue;
        const x=el.x||0, y=el.y||0, w=el.w||vbW, align=el.align||'left';
        const sizePt = el.sizePt||14, font = el.font||'Arial, sans-serif';
        const fill = el.fill || '#000';
        const anchor = align==='center'?'middle':(align==='right'?'end':'start');
        const tx = align==='center'? x+w/2 : (align==='right'? x+w : x);
        parts.push(`<text x="${tx}" y="${y}" font-family="${font}" font-size="${sizePt}pt" fill="${fill}" text-anchor="${anchor}" dominant-baseline="hanging">`+
                   `${val.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</text>`);
      }
    }

    parts.push(`</svg>`);
    return parts.join('');
  }

  async function renderPreview(template, inputs){
    const mount = document.getElementById('svgMount');
    if (!template?.layout){ mount.innerHTML = '<small style="color:#666">No layout on this template.</small>'; return; }

    const baseUrl = (template.layout && template.layout.baseImage) || template.base_image || null;
    const visible = getVisibleFields(template);
    const aligned = normalizeInputsForLayout(template.layout, inputs, visible);
    const svg = await composeSVG(template.layout, aligned, baseUrl);
    mount.innerHTML = svg;
  }

  // ---- Router skip helper ----
  function hasNoRouteFlag(){
    // query + hash flags
    const qs = new URLSearchParams(location.search);
    const h  = new URLSearchParams((location.hash || '').replace(/^#\??/, ''));
    const val = (k) => (qs.get(k) || h.get(k) || '').toString().toLowerCase();
    const flag = val('noroute') || val('router');
    if (flag === '1' || flag === 'true' || flag === 'off') return true;

    // one-shot flag from types page
    try {
      if (sessionStorage.getItem('skipRouterOnce') === '1') {
        sessionStorage.removeItem('skipRouterOnce');
        return true;
      }
    } catch {}

    // if we came from a /types/ page, do not bounce back
    if (document.referrer && /\/types\//.test(document.referrer)) return true;

    return false;
  }

  // ---- TYPE Router (dynamic) ----
  async function routeByType(template, extraParams = {}) {
    // Skip routing if told to
    if (hasNoRouteFlag()) return false;

    const raw = qp('type') || template?.TYPE || template?.type || '';
    const slug = toSlug(raw);
    if (!slug) return false;

    // Generic types page + hash slug avoids per-file creation
    const dest = `types/index.html#/${slug}`;

    // prevent loop if already there
    const path = location.pathname.replace(/^\//, '');
    if (path.endsWith('types/index.html') && location.hash.replace(/^#\/?/, '') === slug) return false;

    // carry through params
    const p = new URLSearchParams(location.search || (location.hash || '').replace(/^#/, ''));
    if (template?.template_id) p.set('template_id', template.template_id);
    for (const [k, v] of Object.entries(extraParams)) {
      if (v != null && v !== '') p.set(k, v);
    }

    location.assign(`${dest}?${p.toString()}`);
    return true;
  }

  // ---- Workflow ----
  function startWorkflow(template, ctx) {
  // reset view + local file URLs
  document.getElementById('templates')?.classList.add('hidden');
  document.getElementById('simPanel')?.classList.add('hidden');
  clearLocalImages();

  const wrap = document.getElementById('customiser');
  wrap.classList.remove('hidden');
  document.getElementById('c-title').textContent = `${template.template_id} — ${template.name||''}`;
  document.getElementById('c-errors').textContent = '';
  document.getElementById('c-done').textContent = '';

  buildForm(template, ctx.prefill);

  // initial preview (uses any prefill)
  renderPreview(template, { ...currentInputsForPreview(template) });

  // live re-render for text/URL changes
  const formEl = document.getElementById('c-form');
  formEl.addEventListener('input', () => {
    renderPreview(template, currentInputsForPreview(template));
  });

  // file → objectURL → preview (delegated listener)
  formEl.addEventListener('change', (e) => {
    const t = e.target;
    if (!t || t.type !== 'file' || !t.id) return;
    const m = t.id.match(/^f_(.+)_file$/);
    if (!m) return;
    const key = m[1];

    // revoke previous
    const prev = localImages.get(key);
    if (prev?.objectUrl) { try { URL.revokeObjectURL(prev.objectUrl); } catch{} }

    // set new (or clear)
    const file = t.files && t.files[0];
    if (file) {
      const objectUrl = URL.createObjectURL(file);
      localImages.set(key, { objectUrl });
      // optionally hint in the URL box
      const urlEl = document.getElementById(`f_${key}_url`);
      if (urlEl) { urlEl.value = ''; urlEl.placeholder = file.name; }
    } else {
      localImages.delete(key);
    }
    renderPreview(template, currentInputsForPreview(template));
  });

  document.getElementById('c-submit').onclick = async () => {
    const { out, errs } = await collectForm(template);
    if (errs.length) { document.getElementById('c-errors').textContent = errs.join(' • '); return; }
    document.getElementById('c-done').textContent = 'All good — ready to generate!';
  };
  document.getElementById('c-cancel').onclick = () => {
    clearLocalImages();
    wrap.classList.add('hidden');
    document.getElementById('templates')?.classList.remove('hidden');
    document.getElementById('simPanel')?.classList.remove('hidden');
  };
}


    // initial preview
    renderPreview(template, { ...ctx.prefill, template_id: template.template_id });

    // re-render on input changes
    document.getElementById('c-form').addEventListener('input', () => {
      const current = {};
      const visible = getVisibleFields(template);
      visible.forEach(f => {
        if (f.type === 'text') {
          const el = document.getElementById(`f_${f.key}`);
          current[f.key] = (el?.value || '').trim();
        }
        if (f.type === 'image') {
          const urlEl = document.getElementById(`f_${f.key}_url`);
          current[f.key] = (urlEl?.value || '').trim();
        }
      });
      renderPreview(template, { ...current, template_id: template.template_id });
    });

    document.getElementById('c-submit').onclick = async () => {
      const { out, errs } = await collectForm(template);
      if (errs.length) { document.getElementById('c-errors').textContent = errs.join(' • '); return; }
      document.getElementById('c-done').textContent = 'All good — ready to generate!';
    };
    document.getElementById('c-cancel').onclick = () => {
      wrap.classList.add('hidden');
      document.getElementById('templates')?.classList.remove('hidden');
      document.getElementById('simPanel')?.classList.remove('hidden');
    };
  }

  // ---- Boot from URL params ----
  async function bootFromJotform(records) {
    const templateId = clean(qp("template_id"));
    const orderId    = qp("orderId");
    const name       = qp("name");
    const photo      = safeUrl(qp("photo"));

    // If no template signal at all, don't auto-start or route
    const typeSlugFromQuery = toSlug(qp('type'));
    if (!templateId && !typeSlugFromQuery) return false;

    // find record by template_id or by type slug
    let tpl = null;
    if (templateId) {
      const wanted = templateId.toLowerCase();
      tpl = records.find(t => (t.template_id||"").toLowerCase() === wanted) || null;
    }
    if (!tpl && typeSlugFromQuery) {
      tpl = records.find(t => (t.type || toSlug(t.TYPE || '')) === typeSlugFromQuery) || null;
    }
    if (!tpl) return false;

    const prefill = {};
    if (Array.isArray(tpl.fields)) {
      for (const f of tpl.fields) {
        if (f.type === "text")  prefill[f.key]  = name || prefill[f.key] || "";
        if (f.type === "image" && photo) prefill[f.key] = photo;
      }
    }

    // Hard skip routing if any skip flag is present
    if (hasNoRouteFlag()) {
      startWorkflow(tpl, { orderId, prefill });
      return true;
    }

    if (await routeByType(tpl, { orderId, name, photo })) return true;
    startWorkflow(tpl, { orderId, prefill });
    return true;
  }

  // ---- Init ----
  (async function init() {
    const records = await renderList();

    // Build indexes for robust lookup
    const byId   = new Map();
    const byType = new Map();
    records.forEach(r => {
      byId.set((r.template_id||'').toLowerCase(), r);
      const slug = (r.type || toSlug(r.TYPE || '')).toLowerCase();
      if (slug) byType.set(slug, r);
    });

    // Click a row to auto-fill simTpl with the clean template_id
    document.getElementById("templates-list").addEventListener("click", (e) => {
      const li = e.target.closest("li");
      if (!li) return;
      const id = parseTemplateId(li.textContent);
      const box = document.getElementById("simTpl");
      if (id && box) box.value = id;
    });

    // Simulator (robust lookup by ID, fallback to TYPE)
    document.getElementById("simBtn").addEventListener("click", async () => {
      const rawTpl  = document.getElementById("simTpl").value;
      const templateId = parseTemplateId(rawTpl).toLowerCase();
      const name    = document.getElementById("simName").value.trim();
      const orderId = document.getElementById("simOrder").value.trim();
      const photo   = document.getElementById("simPhoto").value.trim();

      let tpl = byId.get(templateId);
      if (!tpl) {
        const slug = toSlug(rawTpl);
        tpl = byType.get(slug);
      }

      if (!tpl) {
        console.debug('Lookup failed', { triedId: templateId, raw: rawTpl, ids: Array.from(byId.keys()), types: Array.from(byType.keys()) });
        alert("Template not found.");
        return;
      }

      const prefill = {};
      if (Array.isArray(tpl.fields)) {
        for (const f of tpl.fields) {
          if (f.type === 'text')  prefill[f.key] = name || "";
          if (f.type === 'image' && photo) prefill[f.key] = safeUrl(photo) || "";
        }
      }

      // If skip flags exist, don't route—render here
      if (hasNoRouteFlag()) {
        startWorkflow(tpl, { orderId, prefill });
        return;
      }

      if (await routeByType(tpl, { orderId, name, photo: safeUrl(photo) || '' })) return;
      startWorkflow(tpl, { orderId, prefill });
    });

    // Auto-start if params present
    await bootFromJotform(records);
  })();
  </script>
</body>
</html>
