<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bang Tidy Clothing Customisation App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root { --bd:#ddd; --muted:#666; --bg:#fafafa; --fg:#111; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; color: var(--fg); }
    h1 { margin: 0 0 12px; }
    .card { margin-top: 1rem; padding: 12px; border: 1px solid var(--bd); border-radius: 12px; background: #fff; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    button { padding: 9px 14px; border: 1px solid var(--bd); background: #fff; border-radius: 8px; cursor: pointer; }
    input[type="text"], input[type="url"], input[type="file"] { padding: 9px 10px; border: 1px solid var(--bd); border-radius: 8px; min-width: 220px; }
    label { display:block; font-weight: 600; margin-top: 10px; }
    small { color: var(--muted); }
    ul { padding-left: 18px; margin: 6px 0 0; }
    #templates-status { margin-top:6px; color: var(--muted); }
    .hidden { display: none !important; }
    .error { color: #b00020; }
    .success { color: #0f7b0f; }
  </style>
</head>
<body>
  <h1>Customisation App</h1>

  <!-- Templates list -->
  <div id="templates" class="card">
    <strong>Templates</strong>
    <div id="templates-status">Loading…</div>
    <ul id="templates-list"></ul>
  </div>

  <!-- Simulator -->
  <div class="card" id="simPanel">
    <strong>Simulate Jotform</strong>
    <div class="row" style="margin-top:8px;">
      <input id="simTpl" placeholder="template_id (e.g. CO-CARD-PHOTO-12)" />
      <input id="simName" placeholder="name" />
      <input id="simOrder" placeholder="orderId" />
      <input id="simPhoto" placeholder="photo URL (optional)" />
      <button id="simBtn">Start</button>
    </div>
    <div style="margin-top:8px; color: var(--muted); font-size: 12px;">
      Tip: click a template in the list to auto-fill its ID, then click Start.
    </div>
  </div>

  <!-- Customiser (fallback when no TYPE page exists) -->
  <div id="customiser" class="card hidden">
    <div id="c-head"><strong id="c-title"></strong></div>
    <form id="c-form" style="margin-top:8px;"></form>

    <div id="c-preview" style="margin-top:10px;">
      <div style="margin-bottom:6px;"><strong>Preview</strong></div>
      <div id="svgMount" style="border:1px solid #ddd; border-radius:8px; overflow:hidden;"></div>
    </div>

    <div id="c-errors" class="error" style="margin-top:8px;"></div>
    <div class="row" style="margin-top:10px;">
      <button id="c-submit" type="button">Continue</button>
      <button id="c-cancel" type="button">Cancel</button>
    </div>
    <div id="c-done" class="success" style="margin-top:10px;"></div>
  </div>

  <script>
  // ---- Params ----
  function getParams() {
    const qs = new URLSearchParams(location.search);
    if (qs.toString()) return qs;
    const h = (location.hash || "").replace(/^#/, "");
    return new URLSearchParams(h);
  }
  function qp(k){ return getParams().get(k) || ""; }
  const clean = s => String(s||'').replace(/\s+/g,' ').trim();
  const toSlug = s => clean(s).toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');

  // ---- API base (override allowed, but must be absolute http/https) ----
  const API_BASE = (() => {
    const override = qp('api');
    if (override && /^https?:\/\//i.test(override)) return override;
    return "https://customisationapp-new.vercel.app/api/templates";
  })();

  // ---- API loader ----
  async function loadTemplates() {
    const url = new URL(API_BASE);
    url.searchParams.set('slug','1');
    url.searchParams.set('type','kebab');

    const res = await fetch(url.href, { credentials: "omit", cache: "no-store" });
    const data = await res.json().catch(()=> ({}));
    if (!res.ok || !Array.isArray(data.records)) {
      console.error("Template fetch failed", res.status, data);
      return [];
    }
    return data.records.map(t => {
      const id   = clean(t.template_id);
      const name = clean(t.name);
      const TYPE = clean(t.TYPE || t.type || '');
      const typeKebab = t.type ? clean(t.type) : toSlug(TYPE);
      let base = t.base_image;
      if (Array.isArray(base) && base[0]?.url) base = base[0].url;
      return { ...t, template_id:id, name, TYPE, type:typeKebab, base_image: base || null };
    });
  }

  // ---- Safe URL ----
  function safeUrl(u){ try { const url = new URL(u); return url.href; } catch { return ""; } }

  // ---- Render list ----
  async function renderList() {
    const listEl = document.getElementById("templates-list");
    const statusEl = document.getElementById("templates-status");
    const records = await loadTemplates();

    if (!records.length) { statusEl.textContent = "No templates found"; return records; }
    statusEl.remove();

    const frag = document.createDocumentFragment();
    records.forEach(t => {
      const li = document.createElement("li");
      const typeLabel = (t.type || toSlug(t.TYPE || '')).replace(/-/g,' ');
      const typeTitle = typeLabel ? typeLabel.replace(/\b\w/g, c => c.toUpperCase()) : "";
      li.textContent = `${t.template_id} — ${t.name ?? ""}${typeTitle ? " — TYPE: " + typeTitle : ""}`;
      frag.appendChild(li);
    });
    listEl.appendChild(frag);
    return records;
  }

  // ---- Field helpers (kept simple) ----
  function getVisibleFields(template) {
    const layoutKeys = new Set((template.layout?.elements || []).map(e => e.key).filter(Boolean).map(k=>k.toLowerCase()));
    const wantsPhoto = template.requires_photo !== false;
    const wantsText  = template.requires_text  !== false;

    let fields = Array.isArray(template.fields) ? template.fields : [];
    if (layoutKeys.size) fields = fields.filter(f => layoutKeys.has(String(f.key||'').toLowerCase()));
    fields = fields.filter(f => {
      const t = String(f.type||'').toLowerCase();
      if (t === 'image' && !wantsPhoto) return false;
      if (t === 'text'  && !wantsText)  return false;
      return true;
    });
    fields = fields.filter(f => f.hidden !== true && f.editable !== false);
    return fields;
  }
  function isFieldRequired(template, field) {
    const optAll   = !!template.optional;
    const optPhoto = !!template.optional_photo;
    const optText  = !!template.optional_text;
    const t = String(field.type||'').toLowerCase();
    if (optAll) return false;
    if (t === 'image' && optPhoto) return false;
    if (t === 'text'  && optText)  return false;
    return !!field.required;
  }

  function buildForm(template, prefill) {
    const form = document.getElementById('c-form');
    form.innerHTML = "";
    const fields = getVisibleFields(template);

    fields.forEach(field => {
      const t = String(field.type||'').toLowerCase();
      const wrap = document.createElement('div');
      const required = isFieldRequired(template, field);

      if (t === 'text') {
        const id = `f_${field.key}`;
        wrap.innerHTML = `
          <label for="${id}">${field.label || field.key}</label>
          <input id="${id}" name="${field.key}" type="text"
                 ${field.maxLength ? `maxlength="${field.maxLength}"`:''}
                 ${required ? 'required' : ''}
                 value="${(prefill?.[field.key]||'').replace(/"/g,'&quot;')}">
          ${field.maxLength ? `<small>Max ${field.maxLength} characters</small>` : ''}
          ${required ? `<small>(required)</small>` : `<small>(optional)</small>`}
        `;
      } else if (t === 'image') {
        const id = `f_${field.key}`;
        wrap.innerHTML = `
          <label>${field.label || field.key}</label>
          <input id="${id}_url" type="url" placeholder="Paste image URL" value="${prefill?.[field.key]||''}" ${required ? 'required' : ''}>
          <input id="${id}_file" type="file" accept=".jpg,.jpeg,.png">
          ${required ? `<small>(required)</small>` : `<small>(optional)</small>`}
        `;
      } else {
        wrap.innerHTML = `<label>${field.label || field.key} (unsupported)</label>`;
      }
      form.appendChild(wrap);
    });
  }

  function normalizeInputsForLayout(layout, inputs, fields){
    const out = { ...inputs };
    const byLower = new Map((fields || []).map(f => [String(f.key||'').toLowerCase(), f.key]));
    (layout?.elements || []).forEach(el => {
      const lk = String(el.key||'').toLowerCase();
      if (out[el.key]) return;
      const mappedKey = byLower.get(lk);
      if (mappedKey && out[mappedKey] != null && out[mappedKey] !== '') out[el.key] = out[mappedKey];
    });
    const textKeys  = (fields || []).filter(f => String(f.type||'').toLowerCase() === 'text').map(f => f.key);
    const imageKeys = (fields || []).filter(f => String(f.type||'').toLowerCase() === 'image').map(f => f.key);
    (layout?.elements || []).forEach(el => {
      if (out[el.key]) return;
      if (el.type === 'text'  && textKeys.length  === 1) out[el.key] = inputs[textKeys[0]]  || '';
      if (el.type === 'image' && imageKeys.length === 1) out[el.key] = inputs[imageKeys[0]] || '';
    });
    return out;
  }

  function computeImageFit(imgW, imgH, boxW, boxH, mode='cover'){
    const rImg = imgW / imgH, rBox = boxW / boxH;
    let w,h; if (mode==='cover'){ if (rImg>rBox){ h=boxH; w=h*rImg; } else { w=boxW; h=w/rImg; } }
    else { if (rImg>rBox){ w=boxW; h=w/rImg; } else { h=boxH; w=h*rImg; } }
    return { x:(boxW-w)/2, y:(boxH-h)/2, w, h };
  }

  async function composeSVG(layout, inputs, baseUrl){
    if (!layout) return '';
    const [cw, ch] = layout.canvasMM || [100,100];
    const vbW = cw, vbH = ch;

    const imgInfo = {};
    async function imgSize(url){
      if (!url) return null;
      if (imgInfo[url]) return imgInfo[url];
      const img = new Image(); img.crossOrigin='anonymous';
      const p = new Promise(r=>{ img.onload=()=>r({w:img.naturalWidth,h:img.naturalHeight}); img.onerror=()=>r(null); });
      img.src = url; const s = await p; imgInfo[url]=s; return s;
    }

    const parts = [
      `<svg xmlns="http://www.w3.org/2000/svg" width="${cw}mm" height="${ch}mm" viewBox="0 0 ${vbW} ${vbH}">`,
      `<rect x="0" y="0" width="${vbW}" height="${vbH}" fill="white"/>`
    ];

    if (baseUrl) {
      const s = await imgSize(baseUrl);
      if (s) {
        const fit = computeImageFit(s.w, s.h, vbW, vbH, 'contain');
        parts.push(`<image href="${baseUrl.replace(/"/g,'&quot;')}" x="${fit.x}" y="${fit.y}" width="${fit.w}" height="${fit.h}" preserveAspectRatio="none"/>`);
      } else {
        parts.push(`<image href="${baseUrl.replace(/"/g,'&quot;')}" x="0" y="0" width="${vbW}" height="${vbH}" preserveAspectRatio="none"/>`);
      }
    }

    for (const el of (layout.elements||[])){
      if (el.type==='image'){
        const url = inputs[el.key]; if (!url) continue;
        const box = {x:el.x||0,y:el.y||0,w:el.w||vbW,h:el.h||vbH};
        const s = await imgSize(url);
        if (s){ const fit = computeImageFit(s.w,s.h,box.w,box.h,el.fit||'cover');
          parts.push(`<image href="${url.replace(/"/g,'&quot;')}" x="${box.x+fit.x}" y="${box.y+fit.y}" width="${fit.w}" height="${fit.h}" preserveAspectRatio="none"/>`);
        } else {
          parts.push(`<image href="${url.replace(/"/g,'&quot;')}" x="${box.x}" y="${box.y}" width="${box.w}" height="${box.h}" preserveAspectRatio="none"/>`);
        }
      }
      if (el.type==='text'){
        const val = (inputs[el.key]||'')+''; if (!val) continue;
        const x=el.x||0, y=el.y||0, w=el.w||vbW, align=el.align||'left';
        const sizePt = el.sizePt||14, font = el.font||'Arial, sans-serif';
        const fill = el.fill || '#000';
        const anchor = align==='center'?'middle':(align==='right'?'end':'start');
        const tx = align==='center'? x+w/2 : (align==='right'? x+w : x);
        parts.push(`<text x="${tx}" y="${y}" font-family="${font}" font-size="${sizePt}pt" fill="${fill}" text-anchor="${anchor}" dominant-baseline="hanging">`+
                   `${val.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</text>`);
      }
    }
    parts.push(`</svg>`);
    return parts.join('');
  }

  async function renderPreview(template, inputs){
    const mount = document.getElementById('svgMount');
    if (!template?.layout){ mount.innerHTML = '<small style="color:#666">No layout on this template.</small>'; return; }
    const baseUrl = (template.layout && template.layout.baseImage) || template.base_image || null;
    const visible = getVisibleFields(template);
    const aligned = normalizeInputsForLayout(template.layout, inputs, visible);
    const svg = await composeSVG(template.layout, aligned, baseUrl);
    mount.innerHTML = svg;
  }

  // ---- Router skip helper (loop fix) ----
  function hasNoRouteFlag(){
    const qs = new URLSearchParams(location.search);
    const h  = new URLSearchParams((location.hash || '').replace(/^#\??/, ''));
    const val = (k) => (qs.get(k) || h.get(k) || '').toString().toLowerCase();
    const flag = val('noroute') || val('router');
    if (flag === '1' || flag === 'true' || flag === 'off') return true;
    try {
      if (sessionStorage.getItem('skipRouterOnce') === '1') {
        sessionStorage.removeItem('skipRouterOnce');
        return true;
      }
    } catch {}
    if (document.referrer && /\/types\//.test(document.referrer)) return true;
    return false;
  }

  // ---- TYPE Router (to /types/index.html#/<slug>) ----
  async function routeByType(template, extraParams = {}) {
    if (hasNoRouteFlag()) return false;

    const raw  = qp('type') || template?.TYPE || template?.type || '';
    const slug = toSlug(raw);
    if (!slug) return false;

    const dest = `types/index.html`;
    const path = location.pathname.replace(/^\//, '');
    if (path.endsWith('types/index.html') && location.hash.replace(/^#\/?/, '') === slug) return false;

    const p = new URLSearchParams(location.search || (location.hash || '').replace(/^#/, ''));
    if (template?.template_id) p.set('template_id', template.template_id);
    for (const [k, v] of Object.entries(extraParams)) if (v != null && v !== '') p.set(k, v);
    p.delete('api'); // don’t forward api override

    location.assign(`${dest}?${p.toString()}#/${slug}`);
    return true;
  }

  // ---- Workflow ----
  function startWorkflow(template, ctx) {
    document.getElementById('templates')?.classList.add('hidden');
    document.getElementById('simPanel')?.classList.add('hidden');

    const wrap = document.getElementById('customiser');
    wrap.classList.remove('hidden');
    document.getElementById('c-title').textContent = `${template.template_id} — ${template.name||''}`;
    document.getElementById('c-errors').textContent = '';
    document.getElementById('c-done').textContent = '';

    buildForm(template, ctx.prefill);
    renderPreview(template, { ...ctx.prefill, template_id: template.template_id });

    document.getElementById('c-form').addEventListener('input', () => {
      const current = {};
      const visible = getVisibleFields(template);
      visible.forEach(f => {
        const t = String(f.type||'').toLowerCase();
        if (t === 'text') {
          const el = document.getElementById(`f_${f.key}`);
          current[f.key] = (el?.value || '').trim();
        }
        if (t === 'image') {
          const urlEl = document.getElementById(`f_${f.key}_url`);
          current[f.key] = (urlEl?.value || '').trim();
        }
      });
      renderPreview(template, { ...current, template_id: template.template_id });
    });

    document.getElementById('c-submit').onclick = async () => {
      document.getElementById('c-done').textContent = 'All good — ready to generate!';
    };
    document.getElementById('c-cancel').onclick = () => {
      wrap.classList.add('hidden');
      document.getElementById('templates')?.classList.remove('hidden');
      document.getElementById('simPanel')?.classList.remove('hidden');
    };
  }

  // ---- Boot from URL params ----
  async function bootFromJotform(records) {
    const templateId = clean(qp("template_id"));
    const orderId    = qp("orderId");
    const name       = qp("name");
    const photo      = safeUrl(qp("photo"));

    const typeSlugFromQuery = toSlug(qp('type'));
    if (!templateId && !typeSlugFromQuery) return false;

    let tpl = null;
    if (templateId) {
      const wanted = templateId.toLowerCase();
      tpl = (records||[]).find(t => (t.template_id||"").toLowerCase() === wanted) || null;
    }
    if (!tpl && typeSlugFromQuery) {
      tpl = (records||[]).find(t => (t.type || toSlug(t.TYPE || '')).toLowerCase() === typeSlugFromQuery) || null;
    }
    if (!tpl) return false;

    const prefill = {};
    if (Array.isArray(tpl.fields)) {
      for (const f of tpl.fields) {
        const ft = String(f.type||'').toLowerCase();
        if (ft === "text")  prefill[f.key]  = name || prefill[f.key] || "";
        if (ft === "image" && photo) prefill[f.key] = photo;
      }
    }

    if (hasNoRouteFlag()) { startWorkflow(tpl, { orderId, prefill }); return true; }
    if (await routeByType(tpl, { orderId, name, photo })) return true;
    startWorkflow(tpl, { orderId, prefill });
    return true;
  }

  // ---- Init ----
  (async function init() {
    const records = await renderList();

    // Click a list item to fill simulator
    document.getElementById("templates-list").addEventListener("click", (e) => {
      const li = e.target.closest("li");
      if (!li) return;
      const idMatch = li.textContent.match(/^[A-Z0-9\-_.]+/i);
      const id = idMatch ? idMatch[0] : '';
      const box = document.getElementById("simTpl");
      if (id && box) box.value = id;
    });

    // Simulator
    document.getElementById("simBtn").addEventListener("click", async () => {
      const rawTpl  = document.getElementById("simTpl").value;
      const templateId = clean(rawTpl).toLowerCase();
      const name    = document.getElementById("simName").value.trim();
      const orderId = document.getElementById("simOrder").value.trim();
      const photo   = document.getElementById("simPhoto").value.trim();

      let tpl = records.find(t => (t.template_id||"").toLowerCase() === templateId);
      if (!tpl) {
        const slug = toSlug(rawTpl);
        tpl = records.find(t => (t.type || toSlug(t.TYPE || '')).toLowerCase() === slug);
      }
      if (!tpl) { alert("Template not found."); return; }

      const prefill = {};
      if (Array.isArray(tpl.fields)) {
        for (const f of tpl.fields) {
          const ft = String(f.type||'').toLowerCase();
          if (ft === 'text')  prefill[f.key] = name || "";
          if (ft === 'image' && photo) prefill[f.key] = safeUrl(photo) || "";
        }
      }

      // Router path (set one-time skip to avoid loop on return)
      try { sessionStorage.setItem('skipRouterOnce','1'); } catch {}
      if (await routeByType(tpl, { orderId, name, photo: safeUrl(photo) || '' })) return;
      startWorkflow(tpl, { orderId, prefill });
    });

    await bootFromJotform(records);
  })();
  </script>
</body>
</html>
