// api/templates.js
export default async function handler(req, res) {
  // CORS
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Vary', 'Origin');
  if (req.method === 'OPTIONS') {
    res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    return res.status(204).end();
  }

  const { AIRTABLE_BASE_ID, AIRTABLE_API_KEY } = process.env;
  const TABLE = process.env.AIRTABLE_TABLE || 'templates';
  if (!AIRTABLE_BASE_ID || !AIRTABLE_API_KEY) {
    return res.status(500).json({ error: 'Server misconfigured', details: 'Missing Airtable env vars' });
  }

  const wantSlug  = 'slug' in req.query;          // ?slug=1 -> include { slug: { type } }
  const typeStyle = (req.query.type || '').toString(); // ?type=kebab|raw

  try {
    const records = await fetchAllAirtable({
      baseId: AIRTABLE_BASE_ID,
      apiKey: AIRTABLE_API_KEY,
      table: TABLE,
      view: process.env.AIRTABLE_VIEW || undefined,
    });

    const mapped = records.map((r) => mapRecord(r, { wantSlug, typeStyle }));
    res.setHeader('Content-Type', 'application/json; charset=utf-8');
    return res.status(200).json({ records: mapped });
  } catch (err) {
    console.error('Airtable error', err);
    const details = (err && err.message) || String(err);
    return res.status(500).json({ error: 'Airtable error', details });
  }
}

/* ---------------- helpers ---------------- */

async function fetchAllAirtable({ baseId, apiKey, table, view }) {
  const out = [];
  let url = new URL(`https://api.airtable.com/v0/${encodeURIComponent(baseId)}/${encodeURIComponent(table)}`);
  if (view) url.searchParams.set('view', view);
  // Do NOT request fields[]; unknown columns would 400
  while (true) {
    const r = await fetch(url.toString(), {
      headers: { Authorization: `Bearer ${apiKey}` },
      cache: 'no-store',
    });
    const data = await r.json();
    if (!r.ok) throw new Error(JSON.stringify(data));
    out.push(...(data.records || []));
    if (!data.offset) break;
    url.searchParams.set('offset', data.offset);
  }
  return out;
}

// --- fuzzy field pickers ---
const normKey = k => String(k||'').toLowerCase().replace(/[^a-z0-9]/g,''); // strip spaces/underscores etc.
function pickField(obj, candidates){
  if (!obj) return undefined;
  // 1) exact hits
  for (const c of candidates) if (c in obj) return obj[c];
  // 2) fuzzy: normalise keys and look for the first candidate normalised form
  const map = new Map(Object.keys(obj).map(k => [normKey(k), k]));
  for (const c of candidates) {
    const nk = normKey(c);
    if (map.has(nk)) return obj[map.get(nk)];
  }
  // 3) final fuzzy by contains (e.g., anything that includes "typemeta")
  for (const [nk, orig] of map.entries()) {
    for (const c of candidates) {
      const ck = normKey(c);
      if (nk.includes(ck)) return obj[orig];
    }
  }
  return undefined;
}

function firstNonEmpty(...vals) {
  for (const v of vals) {
    if (v === null || v === undefined) continue;
    if (typeof v === 'string' && v.trim() === '') continue;
    return v;
  }
  return undefined;
}
function clean(s) { return String(s || '').replace(/\s+/g, ' ').trim(); }
function toKebab(s) { return clean(s).toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, ''); }
function toBool(v) {
  if (v === true || v === false) return v;
  const s = String(v || '').trim().toLowerCase();
  if (['1', 'true', 'yes', 'y'].includes(s)) return true;
  if (['0', 'false', 'no', 'n', ''].includes(s)) return false;
  return false;
}
function toObjectJSON(v) {
  try {
    if (!v) return null;
    if (typeof v === 'string') return JSON.parse(v);
    if (typeof v === 'object') return v;
    return null;
  } catch { return null; }
}
function toArrayJSON(v) {
  const o = toObjectJSON(v);
  return Array.isArray(o) ? o : [];
}

function mapRecord(rec, { wantSlug, typeStyle }) {
  const f = rec.fields || {};

  const template_id = clean(firstNonEmpty(
    pickField(f, ['template_id','Template_id','Template ID','template id','TEMPLATE_ID']),
    f.id // absolute last resort
  ));

  const name = clean(firstNonEmpty(
    pickField(f, ['name','Name','title','Title'])
  ));

  // Human “TYPE” (pretty label)
  const TYPE = clean(firstNonEmpty(
    pickField(f, ['TYPE','Type','Type Label','TYPE Label'])
  ));

  // Machine type (kebab). If not present, derive from TYPE.
  const typeRaw = clean(firstNonEmpty(
    pickField(f, ['type','Type_machine','Type (machine)','TYPE (machine)'])
  ));
  const type = (typeStyle === 'raw')
    ? (typeRaw || TYPE || '')
    : toKebab(typeRaw || TYPE || '');

  // JSON blobs (very flexible names):
  const fields_json = pickField(f, ['fields_json','Fields_json','fields','Fields','FIELDS_JSON','Fields JSON']);
  const layout_spec = pickField(f, ['layout_spec','Layout_spec','layout','Layout','LAYOUT_SPEC','Layout Spec']);
  const type_meta   = pickField(f, ['type_meta','TYPE_META','Type_meta','TypeMeta','Type meta','TYPE META','Type Meta']);

  const fields   = toArrayJSON(fields_json);
  const layout   = toObjectJSON(layout_spec);
  const typeMeta = toObjectJSON(type_meta) || {};

  // Optional booleans — tolerate missing/renamed
  const requires_photo = toBool(firstNonEmpty(
    pickField(f, ['requires_photo','Requires_photo','Requires photo','REQUIRES_PHOTO'])
  ));
  const requires_text  = toBool(firstNonEmpty(
    pickField(f, ['requires_text','Requires_text','Requires text','REQUIRES_TEXT'])
  ));
  const optional       = toBool(firstNonEmpty(
    pickField(f, ['optional','Optional'])
  ));
  const optional_photo = toBool(firstNonEmpty(
    pickField(f, ['optional_photo','Optional_photo','Optional photo'])
  ));
  const optional_text  = toBool(firstNonEmpty(
    pickField(f, ['optional_text','Optional_text','Optional text'])
  ));

  // Base image: allow URL string or attachment array
  let base_image = firstNonEmpty(
    pickField(f, ['base_image','Base_image','Base Image','BASE_IMAGE'])
  );

  const out = {
    template_id,
    name,
    TYPE,
    fields,
    layout,
    requires_photo,
    requires_text,
    optional,
    optional_photo,
    optional_text,
    base_image,
    type,
    typeMeta,
  };
  if (wantSlug) out.slug = { type };
  return out;
}
